import { jsPDF } from 'jspdf';
import autoTable from 'jspdf-autotable';
import { Practice, PracticeRecord, ReadinessAnswers, ReadinessScores, CompanyProfile, ResponsibilityMatrixEntry } from '../types';
import { SystemProfile } from '../hooks/useSspData';
import { getCompanyHeaderHtml } from './pdfUtils';

interface SspPdfInput {
  profile: SystemProfile;
  scores: ReadinessScores;
  answers: ReadinessAnswers;
  practices: Practice[];
  records: PracticeRecord[];
  policies: string[];
  companyProfile: CompanyProfile | null;
  responsibilityMatrix: ResponsibilityMatrixEntry[];
}

export const generateSspPdf = async ({ profile, scores, answers, practices, records, policies, companyProfile, responsibilityMatrix }: SspPdfInput) => {
  const doc = new jsPDF();
  const pageHeight = doc.internal.pageSize.height;
  const pageWidth = doc.internal.pageSize.width;
  const margin = 15;
  
  const headerHtml = getCompanyHeaderHtml(companyProfile);
  await doc.html(headerHtml, {
      x: margin,
      y: 15,
      width: pageWidth - (margin * 2),
      windowWidth: 650,
  });

  let yPos = 90;

  const practiceMap = new Map(practices.map(p => [p.id, p]));
  const recordMap = new Map(records.map(r => [r.id, r]));

  const addFooter = () => {
    const pageCount = (doc as any).internal.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(9);
      doc.setTextColor(150);
      doc.text('Generated by CMMC Launch Hub', margin, pageHeight - 10);
      doc.text(`Page ${i} of ${pageCount}`, pageWidth - margin, pageHeight - 10, { align: 'right' });
    }
  };

  // --- Cover Page ---
  doc.setFontSize(22);
  doc.setTextColor(40, 58, 86); // Dark blue
  doc.text('System Security Plan (SSP)', pageWidth / 2, yPos, { align: 'center' });
  yPos += 10;
  doc.setFontSize(14);
  doc.setTextColor(100);
  doc.text(profile.systemName, pageWidth / 2, yPos, { align: 'center' });
  yPos += 10;
  
  autoTable(doc, {
    startY: yPos,
    head: [['Overall Readiness Score', 'Practice Completion', 'Controls Posture']],
    body: [[`${scores.overallReadinessScore}%`, `${scores.practiceCompletionScore}%`, `${scores.controlsPostureScore}%`]],
    theme: 'grid',
    headStyles: { fillColor: [40, 58, 86] }
  });

  yPos = (doc as any).lastAutoTable.finalY + 20;

  doc.setFontSize(11);
  doc.setTextColor(0);
  doc.text(`Primary System Contact: ${profile.contactName} (${profile.contactEmail})`, margin, yPos);

  // --- TOC ---
  doc.addPage();
  await doc.html(headerHtml, { x: margin, y: 15, width: pageWidth - (margin * 2), windowWidth: 650 });
  doc.setFontSize(18).text('Table of Contents', margin, 90);
  autoTable(doc, {
      startY: 100,
      body: [
          ['Section A', 'Overview & Scope'],
          ['Section B', 'System Environment & Boundaries'],
          ['Section C', 'Roles & Responsibilities'],
          ['Section D', 'Control Implementation by Practice'],
          ['Section E', 'Policies & Procedures'],
          ['Section F', 'Risk & Planned Remediation (POA&M)'],
      ],
      theme: 'plain',
  });

  // --- Section A ---
  doc.addPage();
  await doc.html(headerHtml, { x: margin, y: 15, width: pageWidth - (margin * 2), windowWidth: 650 });
  doc.setFontSize(18).text('Section A: Overview & Scope', margin, 90);
  yPos = 105;
  doc.setFontSize(12).text(`This document serves as the System Security Plan (SSP) for the system named "${profile.systemName}" operated by ${profile.organizationName}.`, margin, yPos, { maxWidth: pageWidth - margin * 2 });
  yPos += 20;
  doc.setFontSize(11).text(profile.scopeNotes, margin, yPos, { maxWidth: pageWidth - margin * 2 });
  yPos += 20;
  
  // --- Section B ---
  doc.addPage();
  await doc.html(headerHtml, { x: margin, y: 15, width: pageWidth - (margin * 2), windowWidth: 650 });
  doc.setFontSize(18).text('Section B: System Environment & Boundaries', margin, 90);
  yPos = 105;
  const envText = `The system environment is primarily hosted on ${answers.cloudPlatform}. The network boundary is protected by a business-grade firewall. Remote access for approximately ${answers.remoteWorkerCount} users is facilitated via VPN. The system processes Federal Contract Information (FCI).`;
  doc.setFontSize(11).text(envText, margin, yPos, { maxWidth: pageWidth - margin * 2 });
  
  // --- Section D ---
  doc.addPage();
  await doc.html(headerHtml, { x: margin, y: 15, width: pageWidth - (margin * 2), windowWidth: 650 });
  doc.setFontSize(18).text('Section D: Control Implementation by Practice', margin, 90);
  
  const controlBody = practices.map(p => {
      const record = recordMap.get(p.id);
      const status = record?.status.replace('_', ' ').toUpperCase() || 'NOT ASSESSED';
      let impl = 'Control is not yet implemented. See POA&M.';
      if (status === 'MET') impl = 'All objectives met and control is fully implemented.';
      if (status === 'PARTIAL') impl = 'Control is partially implemented; some objectives remain unmet.';

      const srmEntry = responsibilityMatrix.find(e => e.practiceId === p.id);
      let respText = 'Responsibility not assigned in SRM.';
      if (srmEntry) {
          const companyName = companyProfile?.companyName || 'the organization';
          const { responsibility, providerName, internalOwner } = srmEntry;
          if (responsibility === 'customer') {
              respText = `Responsibility: This control is primarily the responsibility of ${companyName} (Customer).`;
              if (internalOwner) respText += ` Internal Owner: ${internalOwner}.`;
          } else if (responsibility === 'provider') {
              respText = `Responsibility: This control is primarily handled by ${providerName || 'the provider'}. ${companyName} remains responsible for vendor oversight.`;
          } else if (responsibility === 'shared') {
              respText = `Responsibility: This control is shared between ${companyName} and ${providerName || 'the provider'}.`;
              if (internalOwner) respText += ` Internal Owner: ${internalOwner}.`;
          }
      }

      return [p.id, p.name, status, `${impl}\n\n${respText}`];
  });

  autoTable(doc, {
      startY: 100,
      head: [['ID', 'Practice Name', 'Status', 'Implementation Summary']],
      body: controlBody,
      theme: 'striped',
      headStyles: { fillColor: [40, 58, 86] },
      columnStyles: { 1: { cellWidth: 70 } }
  });

  // --- Section C, E, F on new page ---
  doc.addPage();
  await doc.html(headerHtml, { x: margin, y: 15, width: pageWidth - (margin * 2), windowWidth: 650 });
  doc.setFontSize(18).text('Section C: Roles & Responsibilities', margin, 90);
  yPos = 105;
  doc.setFontSize(11).text(`- Management: Provides oversight and resources.\n- IT/MSP: Manages technical controls.\n- Employees: Adhere to policies.`, margin, yPos);
  yPos += 30;

  doc.setFontSize(18).text('Section E: Policies & Procedures', margin, yPos);
  yPos += 15;
  doc.setFontSize(11).text(policies.length > 0 ? policies.join(', ') : 'No formal policies have been identified as active.', margin, yPos);
  yPos += 30;
  
  doc.setFontSize(18).text('Section F: Risk & Planned Remediation (POA&M)', margin, yPos);
  yPos += 15;
  const gaps = records.filter(r => r.status === 'partial' || r.status === 'not_met');
  doc.setFontSize(11).text(`A total of ${gaps.length} practices have been identified with gaps. These will be tracked in a formal Plan of Action & Milestones (POA&M).`, margin, yPos, { maxWidth: pageWidth - margin * 2 });

  addFooter();
  doc.save(`SSP_${profile.organizationName.replace(/ /g, '_')}_${new Date().toISOString().split('T')[0]}.pdf`);
};